#=========================================================================
# RouterBasePRTL.py
#=========================================================================

from pymtl      import *
from pclib.ifcs import NetMsg
from pclib.ifcs import InValRdyBundle, OutValRdyBundle
from pclib.rtl  import Crossbar, NormalQueue, RoundRobinArbiter

#-------------------------------------------------------------------------
# Baseline router datapath
#-------------------------------------------------------------------------

# ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
# LAB TASK: Implement router datapath
# ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

class RouterBaseDpathPRTL( Model ):

  def __init__( s ):
    
    NUM_ROUTERS = 8
    OPAQUE_NBITS = 8
    PAYLOAD_NBITS = 32
    
    #---------------------------------------------------------------------
    # interface
    #---------------------------------------------------------------------
    
    # port 0 input
    
    s.in0_msg = InPort( NetMsg( NUM_ROUTERS, 2**OPAQUE_NBITS, PAYLOAD_NBITS) )
    
    # port 1 input 
    
    s.in1_msg = InPort( NetMsg( NUM_ROUTERS, 2**OPAQUE_NBITS, PAYLOAD_NBITS) )
    
    # port 2 input
    
    s.in2_msg = InPort( NetMsg( NUM_ROUTERS, 2**OPAQUE_NBITS, PAYLOAD_NBITS) )
    
    # port 0 output
    
    s.out0_msg = OutPort( NetMsg( NUM_ROUTERS, 2**OPAQUE_NBITs, PAYLOAD_NBITS) )
    
    # port 1 output
    
    s.out1_msg = OutPort( NetMsg( NUM_ROUTERS, 2**OPAQUE_NBITs, PAYLOAD_NBITS) )
    
    # port 2 output
    
    s.out2_msg = OutPort( NetMsg( NUM_ROUTERS, 2**OPAQUE_NBITs, PAYLOAD_NBITS) )
    
    # Control Signals (ctrl->dpath)
    
    s.xbar_sel0 = InPort (2)
    s.xbar_sel1 = InPort (2)
    s.xbar_sel2 = InPort (2)
    
    # Status Signals (dpath->ctrl)
    
    s.dest0 = OutPort (3)
    s.dest1 = OutPort (3)
    s.dest2 = OutPort (3)
    s.num_free_west = OutPort (2)
    s.num_free_east = OutPort (2)
    
    
    #---------------------------------------------------------------------
    # Structural Composition
    #---------------------------------------------------------------------
    
    # in0_queue
    
    s.in0_queue = m = NormalQueue(4, 46)
    s.connect_pairs(
     m.enq, s.in0_msg,
     m.num_free_entries, s.num_free_west,
    )
    
    s.connect(s.in0_queue.deq[43:46], s.dest0)
    
    # in1_queue
    
    s.in1_queue = m = NormalQueue(4, 46)
    s.connect_pairs(
     m.enq, s.in1_msg,
    )
    
    s.connect(s.in1_queue.deq[43:46], s.dest1)
    
    # in2_queue
    
    s.in2_queue = m = NormalQueue(4, 46)
    s.connect_pairs(
     m.enq, s.in2_msg,
     m.num_free_entries, s.num_free_east,
    )
    
    s.connect(s.in2_queue.deq[43:46], s.dest2)
    
    # xbar
    
    s.xbar = m = Crossbar(3, 46)
    s.connect_pairs(
     m.in_[0], s.in0_queue.deq,
     m.in_[1], s.in1_queue.deq,
     m.in_[2], s.in2_queue.deq,
     m.sel[0], s.xbar_sel0,
     m.sel[1], s.xbar_sel1,
     m.sel[2], s.xbar_sel2,
    )
    
    # port 0 output
    
    s.connect(s.xbar.out[0], s.out0_msg)
    
    # port 1 output
    
    s.connect(s.xbar.out[1], s.out1_msg)
    
    # port 2 output
    
    s.connect(s.xbar.out[2], s.out2_msg)
    
    
    
    
  

#-------------------------------------------------------------------------
# Baseline router control unit
#-------------------------------------------------------------------------

# ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
# LAB TASK: Implement router control unit
# ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

class RouterBaseCtrlPRTL( Model ):

  def __init__( s ):
    pass

#-------------------------------------------------------------------------
# Top-level module
#-------------------------------------------------------------------------

class RouterBasePRTL( Model ):

  #-----------------------------------------------------------------------
  # Constructor
  #-----------------------------------------------------------------------

  def __init__( s, payload_nbits = 32, opaque_nbits = 8, num_routers = 8, router_id = 0 ):

    srcdest_nbits = clog2( num_routers )

    # Interface

    s.in_ = InValRdyBundle [3]( NetMsg(num_routers, 2**opaque_nbits, payload_nbits) )
    s.out = OutValRdyBundle[3]( NetMsg(num_routers, 2**opaque_nbits, payload_nbits) )

    # ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    # LAB TASK: Connect control unit and datapath
    # ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

    # A work-around to get line-trace working

    s.in_msg_opaque = Wire[3]( opaque_nbits  )
    s.in_msg_src    = Wire[3]( srcdest_nbits )
    s.in_msg_dest   = Wire[3]( srcdest_nbits )

    for i in xrange(3):
      s.connect_wire( s.in_msg_opaque[i], s.in_[i].msg.opaque )
      s.connect_wire( s.in_msg_src[i],    s.in_[i].msg.src    )
      s.connect_wire( s.in_msg_dest[i],   s.in_[i].msg.dest   )

  #-----------------------------------------------------------------------
  # Line-trace
  #-----------------------------------------------------------------------

  def line_trace( s ):

    in0_str = "%02s:%1s>%1s" % ( s.in_[0].to_str( s.in_msg_opaque[0] ), s.in_[0].to_str( s.in_msg_src[0] ),s.in_[0].to_str( s.in_msg_dest[0] ) )
    in1_str = "%02s:%1s>%1s" % ( s.in_[1].to_str( s.in_msg_opaque[1] ), s.in_[1].to_str( s.in_msg_src[1] ),s.in_[1].to_str( s.in_msg_dest[1] ) )
    in2_str = "%02s:%1s>%1s" % ( s.in_[2].to_str( s.in_msg_opaque[2] ), s.in_[2].to_str( s.in_msg_src[2] ),s.in_[2].to_str( s.in_msg_dest[2] ) )

    return "({}|{}|{})".format( in0_str, in1_str, in2_str )
